---
title: "ã€Vulkanã€‘BufferDeviceAddressã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ¥½ã«ã—ãŸã„"
emoji: "ğŸ“"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [cpp, vulkan, glsl]
published: false
---

# ã¯ã˜ã‚ã«

Vulkan ã§ã¯ã€é€šå¸¸ã®ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¨ã¯åˆ¥ã« **Buffer Device Address** ã¨ã„ã†æ©Ÿèƒ½ã§ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒã‚¤ãƒ³ã‚¿ã¨ä¼¼ãŸã‚ˆã†ãªæ©Ÿèƒ½ã§ã™ã€‚ç‰¹ã«ã€ãƒ¬ã‚¤ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã¯ã€é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«æ ¼ç´ã—ã¦ãŠãã€ **Buffer Device Address** ã‚’ä½¿ã£ã¦ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚

ã“ã®è¨˜äº‹ã§ã¯ã€**Buffer Device Address** ã‚’ä½¿ã£ã¦Chitã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰ãƒ’ãƒƒãƒˆã—ãŸãƒ¡ãƒƒã‚·ãƒ¥ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€é ‚ç‚¹ä½ç½®ã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

# GLSLæº–å‚™

GLSLå´ã§ã¯ä»¥ä¸‹ã®æº–å‚™ã‚’ã—ã¾ã™ã€‚
- å¿…è¦ãªæ‹¡å¼µæ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
- å¿…è¦ãªã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒãŸã›ã‚‹æ§‹é€ ä½“ `MeshAddress` ã®é…åˆ—ã‚’å—ã‘å–ã‚‹
- `buffer_reference` ã‚’ä½¿ã£ã¦é ‚ç‚¹é…åˆ—ã‚’ç”¨æ„ã™ã‚‹

```glsl:sample.rchit
#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

struct MeshAddress
{
    uint64_t vertices;
    uint64_t indices;
};

struct Vertex
{
    vec3 pos;
};

layout(binding = 0) buffer Addresses { MeshAddress addresses[]; };
layout(buffer_reference, scalar) buffer Vertices { Vertex v[]; };
layout(buffer_reference, scalar) buffer Indices { uvec3 i[]; };
```

# Vulkanæº–å‚™

Vulkanå´ã§ã¯ä»¥ä¸‹ã®æº–å‚™ã‚’ã—ã¾ã™ã€‚
- å¿…è¦ãªFeatureã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
- `vk::DeviceAddress` ã‚’å«ã‚€ `BufferAddress` æ§‹é€ ä½“ã‚’ä½œæˆã™ã‚‹
- å‚ç…§ã—ãŸã„ãƒãƒƒãƒ•ã‚¡ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã™ã‚‹
- `BufferAddress` é…åˆ—ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä½œã‚‹

```cpp:main.cpp
void createDevice()
{
    // Featuresã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
    vk::PhysicalDeviceFeatures deviceFeatures;
    deviceFeatures.shaderInt64 = true;

    vk::PhysicalDeviceBufferDeviceAddressFeatures addressFeatures;
    addressFeatures.bufferDeviceAddress = true;

    vk::PhysicalDeviceScalarBlockLayoutFeatures scalarBlockFeatures;
    scalarBlockFeatures.scalarBlockLayout = true;

    // ...
}

struct BufferAddress
{
    vk::DeviceAddress vertices;
    vk::DeviceAddress indices;
};

void prepare(){
    // ãƒãƒƒãƒ•ã‚¡ã«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒãŸã›ã‚‹
    std::vector<BufferAddress> addresses;
    for(auto&& mesh: meshes){
    BufferAddress address;
    address.vertices = mesh.vertexBuffer.deviceAddress;
    address.indices = mesh.indexBuffer.deviceAddress;
    addresses.push_back(address);
    }

    // ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆ
    addressBuffer = createBuffer(
        sizeof(BufferAddress) * addresses.size(), 
        vk::BufferUsageFlagBits::eStorageBuffer |
        vk::BufferUsageFlagBits::eShaderDeviceAddress);

    descSet.update("Addresses", addressBuffer);
}
```

# GLSLã§ä½¿ã†

```glsl:sample.rchit
// ãƒ’ãƒƒãƒˆã—ãŸãƒ¡ãƒƒã‚·ãƒ¥ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹
MeshAddress address = addresses[gl_InstanceID];

// ãƒãƒƒãƒ•ã‚¡ã‚’å‚ç…§ã™ã‚‹
Vertices vertices = Vertices(address.vertices);
Indices indices = Indices(address.indices);

// é ‚ç‚¹ã‚’å–å¾—ã™ã‚‹
uvec3 index = indices.i[gl_PrimitiveID];
Vertex v0 = vertices.v[index.x];
Vertex v1 = vertices.v[index.y];
Vertex v2 = vertices.v[index.z];
````

ã“ã‚“ãªæ„Ÿã˜ã§ã‚­ãƒ¬ã‚¤ã«æ›¸ã‘ã¾ã™ã€‚
ãŠã‚ã‚Šã§ã™ã€‚
